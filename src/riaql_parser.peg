query <- (SELECT select_clause)
         (FROM from_clause)
         (JOIN join_clause)?
         (WHERE where_clause)?
`
[{Action, Clause} || [Action, Clause] <- Node]
`;

SELECT <- space* 'SELECT' space+ `select`;

select_clause <- '*' / ((keymap / key) (',' space (keymap / key))*)
`
case Node of
    <<"*">> ->
        Node;
    [Key,[]] ->
        [Key];
    [Key1,List] ->
        [Key1|[KeyN || [_,_,KeyN] <- List]]
end
`;

JOIN <- space+ 'JOIN' space+ `join`;
ON <- space+ 'ON' space+ `on`;

join_clause <- name ON name
`
[Collection,_,Key]=Node,
{Collection,Key}
`;

FROM <- space+ 'FROM' space+ `from`;

from_clause <- function / name ~;

WHERE <- space+ 'WHERE' space+ `where`;

where_clause <- expr ((',' / (space 'AND' space)) space? expr)*
`
[Where1|Rest]=Node,
case Rest of
    [[]] -> [Where1];
    _ -> [Where1|[WhereN || [[_,_,WhereN]] <- Rest]]
end
`;

function <- name '(' value (',' space* value)* ')'
`
[Name,_,Val1,Vals,_]=Node,
apply(?MODULE, binary_to_atom(Name, utf8), [Val1|[ValN || [_,_,ValN] <- Vals]])
`;

comparator <- '=' / '!=' / '<=' / '>=' / '<' / '>' `binary_to_atom(iolist_to_binary(Node), latin1)`;

or <- space+ 'OR' space+ `'or'`;
expr <- name space? comparator space? value (or expr)?
`
[Key,_,Comparator,_,Value|Rest]=Node,
Expr1 = {Comparator, Key, Value},
case Rest of
    [[]] -> Expr1;
    [['or', {_,_,_}=Expr2]] -> {'or', Expr1, Expr2}
end
`;

value <- string / number ~;

string <- '"' chars:(!'"' ("\\\\" / '\\"' / .))* '"' `iolist_to_binary(proplists:get_value(chars, Node))`;
number <- float / int ~;

key <- name
`
{Node,Node}
`;

AS <- space+ "AS" space+ `as`;
keymap <- name AS name
`
[Key,as,Alias]=Node,
{Alias,Key}
`;

name <- [A-z] ([A-z] / [0-9])*
`
iolist_to_binary(Node)
`;

int <- '-'? non_zero_digit digit*
`
list_to_integer(binary_to_list(iolist_to_binary(Node)))
`;
float <- int '.' digit+
`
list_to_float(binary_to_list(iolist_to_binary(Node)))
`;
non_zero_digit <- [1-9] ~;
digit <- [0-9] ~;
space <- [ \t\n\s\r] ~;

`
-export([bucket/1,index/3,index/4]).

bucket(Bucket) ->
    Bucket.

index(Bucket, Index, Key) ->
    {index, Bucket, Index, Key}.
index(Bucket, Index, StartKey, EndKey) ->
    {index, Bucket, Index, StartKey, EndKey}.
`
